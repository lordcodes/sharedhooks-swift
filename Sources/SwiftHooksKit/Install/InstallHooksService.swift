// Copyright Â© 2022 Andrew Lord.

import Files

// TODO: Add tests

/// Service to install project git hooks into .git.
///
/// Handles non-SwiftHooks hooks that are already found by backing them up and
/// will also overwrite old SwiftHooks hook files.
public struct InstallHooksService {
    /// Create the service.
    public init() {}

    /// Entry-point to run the service.
    /// - throws: ExitCode when operation ends early due to success or failure.  
    public func run() throws {
        printer.printMessage("ðŸ”¨ Installing project Git hooks")

        try installGitHooks()
    }

    private func installGitHooks() throws {
        let gitHooksDirectory = try handleFatalError(using: printer) {
            try Folder.current.gitHooks()
        }
        let projectHooksDirectory = try handleFatalError(using: printer) {
            try Folder.current.projectHooks()
        }

        for hook in gitHooks {
            if !projectHooksDirectory.containsSubfolder(named: hook) {
                continue
            }
            handleNonFatalError(using: printer) {
                let hookFile = try resolveHookFile(hook, in: gitHooksDirectory)
                try setupFileAsHookFile(file: hookFile, for: hook)
            }
        }
    }

    private func resolveHookFile(_ hook: String, in gitHooksDirectory: Folder) throws -> File {
        if gitHooksDirectory.containsFile(named: hook) {
            try handleExistingHookFile(hook, in: gitHooksDirectory)
        }
        return try createNewHookFile(for: hook, in: gitHooksDirectory)
    }

    private func handleExistingHookFile(_ hook: String, in gitHooksDirectory: Folder) throws {
        guard let existingFile = try? gitHooksDirectory.file(named: hook) else {
            return
        }
        let hookContents = try readHookFileContents(hook: hook, file: existingFile)
        if hookContents.contains(autoGeneratedIdentifier) {
            printer.printMessage("\(hook): found SwiftHooks file, deleting it before installâ€¦")
            try deleteExistingHookFile(hook: hook, file: existingFile)
        } else {
            printer.printMessage("\(hook): found non-SwiftHooks file, backing it upâ€¦")
            try backupNoGeneratedHookFile(hook: hook, file: existingFile)
        }
    }

    private func readHookFileContents(hook: String, file: File) throws -> String {
        do {
            return try file.readAsString()
        } catch is ReadError {
            throw SwiftHooksError.resovingHookFile(hook: hook, reason: .readExistingHookFileContents)
        }
    }

    private func deleteExistingHookFile(hook: String, file: File) throws {
        do {
            try file.delete()
        } catch is LocationError {
            throw SwiftHooksError.resovingHookFile(hook: hook, reason: .deletingExisting)
        }
    }

    private func backupNoGeneratedHookFile(hook: String, file: File) throws {
        do {
            try file.rename(to: "\(file.name).backup", keepExtension: false)
        } catch is LocationError {
            throw SwiftHooksError.resovingHookFile(hook: hook, reason: .renamingBackup)
        }
    }

    private func createNewHookFile(for hook: String, in gitHooksDirectory: Folder) throws -> File {
        do {
            return try gitHooksDirectory.createFile(named: hook)
        } catch is WriteError {
            throw SwiftHooksError.resovingHookFile(hook: hook, reason: .creatingNew)
        }
    }

    private func setupFileAsHookFile(file: File, for hook: String) throws {
        printer.printMessage("\(hook): writing hook file contentsâ€¦")
        do {
            try file.write(hookTemplate)
            try file.setPermissions(
                owner: [.execute, .write, .read],
                group: [.execute, .write, .read],
                others: [.execute, .write, .read]
            )
        } catch is PermissionsError {
            throw SwiftHooksError.settingPermissionsOnHookFile(hook: hook)
        } catch is WriteError {
            throw SwiftHooksError.writingToHookFile(hook: hook)
        }
    }
}
